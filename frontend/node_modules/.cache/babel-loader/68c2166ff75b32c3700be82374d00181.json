{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar color_1 = require(\"../color\");\n\nvar vbox_1 = __importDefault(require(\"./vbox\"));\n\nvar pqueue_1 = __importDefault(require(\"./pqueue\"));\n\nvar fractByPopulations = 0.75;\n\nfunction _splitBoxes(pq, target) {\n  var lastSize = pq.size();\n\n  while (pq.size() < target) {\n    var vbox = pq.pop();\n\n    if (vbox && vbox.count() > 0) {\n      var _a = vbox.split(),\n          vbox1 = _a[0],\n          vbox2 = _a[1];\n\n      pq.push(vbox1);\n      if (vbox2 && vbox2.count() > 0) pq.push(vbox2); // No more new boxes, converged\n\n      if (pq.size() === lastSize) {\n        break;\n      } else {\n        lastSize = pq.size();\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nvar MMCQ = function (pixels, opts) {\n  if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n    throw new Error('Wrong MMCQ parameters');\n  }\n\n  var vbox = vbox_1.default.build(pixels);\n  var hist = vbox.hist;\n  var colorCount = Object.keys(hist).length;\n  var pq = new pqueue_1.default(function (a, b) {\n    return a.count() - b.count();\n  });\n  pq.push(vbox); // first set of colors, sorted by population\n\n  _splitBoxes(pq, fractByPopulations * opts.colorCount); // Re-order\n\n\n  var pq2 = new pqueue_1.default(function (a, b) {\n    return a.count() * a.volume() - b.count() * b.volume();\n  });\n  pq2.contents = pq.contents; // next set - generate the median cuts using the (npix * vol) sorting.\n\n  _splitBoxes(pq2, opts.colorCount - pq2.size()); // calculate the actual colors\n\n\n  return generateSwatches(pq2);\n};\n\nfunction generateSwatches(pq) {\n  var swatches = [];\n\n  while (pq.size()) {\n    var v = pq.pop();\n    var color = v.avg();\n    var r = color[0],\n        g = color[1],\n        b = color[2];\n    swatches.push(new color_1.Swatch(color, v.count()));\n  }\n\n  return swatches;\n}\n\nexports.default = MMCQ;","map":{"version":3,"mappings":"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","names":["fractByPopulations","_splitBoxes","pq","target","lastSize","size","vbox","pop","count","split","vbox1","vbox2","push","MMCQ","pixels","opts","length","colorCount","Error","vbox_1","build","hist","Object","keys","pqueue_1","a","b","pq2","volume","contents","generateSwatches","swatches","v","color","avg","g","color_1","exports"],"sources":["/home/fortnyce/Desktop/work_schedule_assigner/node_modules/node-vibrant/src/quantizer/mmcq.ts"],"sourcesContent":["import {\n  Quantizer,\n  Filter,\n  Pixels,\n  ComputedOptions\n} from '../typing'\nimport { Swatch } from '../color'\nimport VBox from './vbox'\nimport PQueue from './pqueue'\n\nconst fractByPopulations = 0.75\n\nfunction _splitBoxes (pq: PQueue<VBox>, target: number): void {\n  let lastSize = pq.size()\n  while (pq.size() < target) {\n    let vbox = pq.pop()\n\n    if (vbox && vbox.count() > 0) {\n      let [vbox1, vbox2] = vbox.split()\n\n      pq.push(vbox1)\n      if (vbox2 && vbox2.count() > 0) pq.push(vbox2)\n\n      // No more new boxes, converged\n      if (pq.size() === lastSize) {\n        break\n      } else {\n        lastSize = pq.size()\n      }\n    } else {\n      break\n    }\n  }\n}\n\nconst MMCQ = (pixels: Pixels, opts: ComputedOptions): Array<Swatch> => {\n  if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n    throw new Error('Wrong MMCQ parameters')\n  }\n\n  let vbox = VBox.build(pixels)\n  let hist = vbox.hist\n  let colorCount = Object.keys(hist).length\n  let pq = new PQueue<VBox>((a, b) => a.count() - b.count())\n\n  pq.push(vbox)\n\n  // first set of colors, sorted by population\n  _splitBoxes(pq, fractByPopulations * opts.colorCount)\n\n  // Re-order\n  let pq2 = new PQueue<VBox>((a, b) => a.count() * a.volume() - b.count() * b.volume())\n  pq2.contents = pq.contents\n\n  // next set - generate the median cuts using the (npix * vol) sorting.\n  _splitBoxes(pq2, opts.colorCount - pq2.size())\n\n  // calculate the actual colors\n  return generateSwatches(pq2)\n}\n\nfunction generateSwatches (pq: PQueue<VBox>) {\n  let swatches: Swatch[] = []\n  while (pq.size()) {\n    let v = pq.pop()\n    let color = v.avg()\n    let [r, g, b] = color\n    swatches.push(new Swatch(color, v.count()))\n  }\n  return swatches\n}\n\nexport default MMCQ\n"]},"metadata":{},"sourceType":"script"}